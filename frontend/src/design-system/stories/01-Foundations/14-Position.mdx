---
title: 'Position'
description: 'Comprehensive positioning system for element placement and layout control. Includes position types, stacking contexts, and z-index management.'
parameters:
  docs:
    description:
      component: 'Our positioning system provides a consistent approach to controlling element placement and creating complex layouts through carefully crafted position and z-index tokens.'
    canvas:
      sourceState: 'hidden'
---

import { Meta, Story, Canvas, ArgsTable } from '@storybook/blocks';
import { tokens } from '../../tokens';

<Meta
  title="Design System/Foundations/Position"
  parameters={{
    viewMode: 'docs',
    previewTabs: {
      canvas: { hidden: true },
    },
  }}
/>

# Position

Our positioning system provides a consistent approach to controlling element placement and creating complex layouts through carefully crafted position and z-index tokens.

## Overview

The positioning system is designed to create precise element placement and control stacking order across all components. It provides comprehensive tokens for position types, z-index management, and stacking context control that work seamlessly with our layout and spacing systems.

## Token Definitions

### Position Types

```typescript
tokens.position = {
  static: 'static',
  relative: 'relative',
  absolute: 'absolute',
  fixed: 'fixed',
  sticky: 'sticky',
};
```

### Z-Index Scale

```typescript
tokens.zIndex = {
  0: '0',
  10: '10',
  20: '20',
  30: '30',
  40: '40',
  50: '50',
  dropdown: '1000',
  sticky: '1020',
  fixed: '1030',
  modal: '1040',
  popover: '1050',
  tooltip: '1060',
};
```

### Positioning Utilities

```typescript
tokens.positioning = {
  inset: {
    0: '0',
    auto: 'auto',
    full: '100%',
  },
  top: {
    0: '0',
    auto: 'auto',
    full: '100%',
  },
  right: {
    0: '0',
    auto: 'auto',
    full: '100%',
  },
  bottom: {
    0: '0',
    auto: 'auto',
    full: '100%',
  },
  left: {
    0: '0',
    auto: 'auto',
    full: '100%',
  },
};
```

## Usage Rules

### 1. **Position Types**

- **Static**: Default positioning, follows normal document flow
- **Relative**: Positioned relative to its normal position
- **Absolute**: Positioned relative to nearest positioned ancestor
- **Fixed**: Positioned relative to viewport
- **Sticky**: Positioned based on scroll position

### 2. **Z-Index Usage**

- **0-50**: Base content and background elements
- **1000+**: UI overlays and interactive elements
- **Dropdown (1000)**: Navigation menus and dropdowns
- **Modal (1040)**: Dialog overlays and modals
- **Tooltip (1060)**: Highest priority for help text

### 3. **Stacking Context**

- **Parent containers**: Create new stacking contexts
- **Z-index values**: Control stacking order within context
- **Position types**: Affect stacking context creation
- **Opacity/transform**: Can create new stacking contexts

## Best Practices

### 1. **Consistent Z-Index Usage**

```tsx
// ✅ Good - Consistent z-index usage
<div style={{
  position: tokens.position.absolute,
  top: tokens.positioning.top[0],
  right: tokens.positioning.right[0],
  zIndex: tokens.zIndex.dropdown,
}}>
  Dropdown menu
</div>

<div style={{
  position: tokens.position.fixed,
  top: tokens.positioning.top[0],
  left: tokens.positioning.left[0],
  right: tokens.positioning.right[0],
  zIndex: tokens.zIndex.modal,
}}>
  Modal overlay
</div>

// ❌ Bad - Arbitrary z-index values
<div style={{
  position: 'absolute',
  top: 0,
  right: 0,
  zIndex: 1500,
}}>
  Arbitrary z-index
</div>
```

### 2. **Proper Positioning Context**

```tsx
// ✅ Good - Proper positioning context
<div style={{ position: tokens.position.relative }}>
  <div style={{
    position: tokens.position.absolute,
    top: tokens.positioning.top[0],
    left: tokens.positioning.left[0],
  }}>
    Positioned relative to parent
  </div>
</div>

// ❌ Bad - Missing positioning context
<div>
  <div style={{
    position: tokens.position.absolute,
    top: tokens.positioning.top[0],
    left: tokens.positioning.left[0],
  }}>
    Positioned relative to viewport
  </div>
</div>
```

### 3. **Responsive Positioning**

```tsx
// ✅ Good - Responsive positioning
<div style={{
  position: tokens.position.sticky,
  top: tokens.positioning.top[0],
  zIndex: tokens.zIndex.sticky,
  '@media (max-width: 768px)': {
    position: tokens.position.fixed,
    bottom: tokens.positioning.bottom[0],
    top: 'auto',
  },
}}>
  Responsive header
</div>

// ❌ Bad - Fixed positioning without responsiveness
<div style={{
  position: tokens.position.fixed,
  top: tokens.positioning.top[0],
  zIndex: tokens.zIndex.sticky,
}}>
  Fixed header
</div>
```

### 4. **Accessibility Considerations**

```tsx
// ✅ Good - Accessible positioning
<div style={{
  position: tokens.position.absolute,
  top: tokens.positioning.top.full,
  left: tokens.positioning.left[0],
  zIndex: tokens.zIndex.tooltip,
}} role="tooltip" aria-hidden="true">
  Accessible tooltip
</div>

// ❌ Bad - Positioning without accessibility
<div style={{
  position: tokens.position.absolute,
  top: tokens.positioning.top.full,
  left: tokens.positioning.left[0],
  zIndex: tokens.zIndex.tooltip,
}}>
  Inaccessible tooltip
</div>
```

## How-To Guides

### Creating a Tooltip Component

```tsx
import { tokens } from '@/design-system/tokens';

interface TooltipProps {
  content: string;
  children: React.ReactNode;
  position?: 'top' | 'bottom' | 'left' | 'right';
}

const Tooltip = ({ content, children, position = 'top' }: TooltipProps) => {
  const getPositionStyle = () => {
    switch (position) {
      case 'top':
        return {
          bottom: tokens.positioning.bottom.full,
          left: tokens.positioning.left['50%'],
          transform: 'translateX(-50%)',
        };
      case 'bottom':
        return {
          top: tokens.positioning.top.full,
          left: tokens.positioning.left['50%'],
          transform: 'translateX(-50%)',
        };
      case 'left':
        return {
          top: tokens.positioning.top['50%'],
          right: tokens.positioning.right.full,
          transform: 'translateY(-50%)',
        };
      case 'right':
        return {
          top: tokens.positioning.top['50%'],
          left: tokens.positioning.left.full,
          transform: 'translateY(-50%)',
        };
    }
  };

  return (
    <div
      style={{ position: tokens.position.relative, display: 'inline-block' }}
    >
      {children}
      <div
        style={{
          position: tokens.position.absolute,
          zIndex: tokens.zIndex.tooltip,
          backgroundColor: tokens.colors.secondary[900],
          color: tokens.colors.white,
          padding: tokens.spacing[2],
          borderRadius: tokens.borderRadius.sm,
          fontSize: tokens.typography.fontSize.sm,
          whiteSpace: 'nowrap',
          pointerEvents: 'none',
          opacity: 0,
          transition: 'opacity 0.2s ease',
          ...getPositionStyle(),
        }}
        role="tooltip"
      >
        {content}
      </div>
    </div>
  );
};
```

### Creating a Fixed Header Component

```tsx
interface FixedHeaderProps {
  children: React.ReactNode;
  variant?: 'default' | 'elevated';
}

const FixedHeader = ({ children, variant = 'default' }: FixedHeaderProps) => {
  const getHeaderStyle = () => ({
    position: tokens.position.fixed,
    top: tokens.positioning.top[0],
    left: tokens.positioning.left[0],
    right: tokens.positioning.right[0],
    zIndex: tokens.zIndex.fixed,
    backgroundColor: tokens.colors.white,
    borderBottom: `1px solid ${tokens.colors.secondary[200]}`,
    padding: tokens.spacing[4],
    ...(variant === 'elevated' && {
      boxShadow: tokens.shadows.md,
    }),
  });

  return <header style={getHeaderStyle()}>{children}</header>;
};
```

### Creating a Modal Component

```tsx
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const Modal = ({ isOpen, onClose, children }: ModalProps) => {
  if (!isOpen) return null;

  return (
    <div
      style={{
        position: tokens.position.fixed,
        top: tokens.positioning.top[0],
        left: tokens.positioning.left[0],
        right: tokens.positioning.right[0],
        bottom: tokens.positioning.bottom[0],
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: tokens.zIndex.modal,
        padding: tokens.spacing[4],
      }}
      onClick={onClose}
    >
      <div
        style={{
          backgroundColor: tokens.colors.white,
          borderRadius: tokens.borderRadius.lg,
          padding: tokens.spacing[8],
          maxWidth: '500px',
          width: '100%',
          maxHeight: '90vh',
          overflow: 'auto',
          boxShadow: tokens.shadows.xl,
        }}
        onClick={e => e.stopPropagation()}
      >
        {children}
      </div>
    </div>
  );
};
```

## Common Patterns

### Sticky Navigation

```tsx
const StickyNavigation = () => {
  return (
    <nav
      style={{
        position: tokens.position.sticky,
        top: tokens.positioning.top[0],
        zIndex: tokens.zIndex.sticky,
        backgroundColor: tokens.colors.white,
        borderBottom: `1px solid ${tokens.colors.secondary[200]}`,
        padding: tokens.spacing[4],
      }}
    >
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          maxWidth: tokens.layout.containers.lg,
          margin: '0 auto',
        }}
      >
        <div style={{ fontWeight: tokens.typography.fontWeight.bold }}>
          Logo
        </div>
        <div
          style={{
            display: 'flex',
            gap: tokens.spacing[6],
          }}
        >
          <a href="#" style={{ color: tokens.colors.secondary[700] }}>
            Home
          </a>
          <a href="#" style={{ color: tokens.colors.secondary[700] }}>
            About
          </a>
          <a href="#" style={{ color: tokens.colors.secondary[700] }}>
            Contact
          </a>
        </div>
      </div>
    </nav>
  );
};
```

### Floating Action Button

```tsx
const FloatingActionButton = () => {
  return (
    <button
      style={{
        position: tokens.position.fixed,
        bottom: tokens.spacing[6],
        right: tokens.spacing[6],
        width: tokens.sizing.width[16],
        height: tokens.sizing.height[16],
        borderRadius: tokens.borderRadius.full,
        backgroundColor: tokens.colors.primary[500],
        color: tokens.colors.white,
        border: 'none',
        boxShadow: tokens.shadows.lg,
        cursor: 'pointer',
        zIndex: tokens.zIndex.fixed,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: tokens.typography.fontSize.xl,
      }}
    >
      +
    </button>
  );
};
```

### Overlay Positioning

```tsx
const OverlayExample = () => {
  return (
    <div style={{ position: tokens.position.relative, height: '200px' }}>
      <div
        style={{
          position: tokens.position.absolute,
          top: tokens.positioning.top[0],
          left: tokens.positioning.left[0],
          right: tokens.positioning.right[0],
          bottom: tokens.positioning.bottom[0],
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: tokens.zIndex.modal,
        }}
      >
        <div
          style={{
            backgroundColor: tokens.colors.white,
            padding: tokens.spacing[6],
            borderRadius: tokens.borderRadius.lg,
            textAlign: 'center',
          }}
        >
          <h3 style={{ marginBottom: tokens.spacing[4] }}>Overlay Content</h3>
          <p>This content is positioned over the background</p>
        </div>
      </div>
    </div>
  );
};
```

## Accessibility Guidelines

### 1. **Focus Management**

- Ensure positioned elements don't interfere with focus order
- Provide proper focus indicators for positioned elements
- Test keyboard navigation through positioned content

### 2. **Screen Reader Support**

- Use appropriate ARIA attributes for positioned elements
- Ensure positioned content is announced correctly
- Test with screen readers on different devices

### 3. **Responsive Accessibility**

- Ensure positioned elements work on mobile devices
- Test touch interactions with positioned elements
- Maintain accessibility across different screen sizes

### 4. **Z-Index Management**

- Avoid creating inaccessible stacking contexts
- Ensure important content remains visible
- Test with different zoom levels and screen readers

## Testing Checklist

- [ ] Positioning works correctly across all screen sizes
- [ ] Z-index values create proper stacking order
- [ ] Positioned elements are accessible
- [ ] Focus management works with positioned elements
- [ ] Screen readers can access positioned content
- [ ] Touch interactions work on mobile devices
- [ ] Stacking contexts are properly managed

## Resources

- [CSS Position Property](https://developer.mozilla.org/en-US/docs/Web/CSS/position)
- [Z-Index and Stacking Context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index)
- [Positioning Accessibility](https://www.w3.org/WAI/WCAG21/Understanding/info-and-relationships.html)
