---
title: 'Border'
description: 'Comprehensive border system for element boundaries and visual separation. Includes border styles, colors, and responsive border utilities.'
parameters:
  docs:
    description:
      component: 'Our border system provides a consistent approach to creating element boundaries and visual separation through carefully crafted border styles, colors, and utilities.'
    canvas:
      sourceState: 'hidden'
---

import { Meta, Story, Canvas, ArgsTable } from '@storybook/blocks';
import { tokens } from '../../tokens';

<Meta
  title="Design System/Foundations/Border"
  parameters={{
    viewMode: 'docs',
    previewTabs: {
      canvas: { hidden: true },
    },
  }}
/>

# Border

Our border system provides a consistent approach to creating element boundaries and visual separation through carefully crafted border styles, colors, and utilities.

## Overview

The border system is designed to create clear visual hierarchy and improve user experience through consistent border styling across all components. It provides comprehensive tokens for border styles, colors, widths, and responsive border utilities that work seamlessly with our color and spacing systems.

## Token Definitions

### Border Styles

```typescript
tokens.border = {
  style: {
    solid: 'solid',
    dashed: 'dashed',
    dotted: 'dotted',
    double: 'double',
    none: 'none',
  },
  width: {
    0: '0px',
    1: '1px',
    2: '2px',
    3: '3px',
    4: '4px',
    8: '8px',
  },
  color: {
    primary: tokens.colors.primary[500],
    secondary: tokens.colors.secondary[200],
    accent: tokens.colors.accent[500],
    destructive: tokens.colors.destructive[500],
    success: tokens.colors.success,
    warning: tokens.colors.warning,
    info: tokens.colors.info,
    transparent: 'transparent',
  },
};
```

### Border Radius

```typescript
tokens.borderRadius = {
  none: '0px',
  sm: '2px',
  md: '6px',
  lg: '12px',
  xl: '16px',
  '2xl': '24px',
  '3xl': '32px',
  full: '9999px',
};
```

### Border Utilities

```typescript
tokens.borderUtils = {
  sides: {
    top: 'border-top',
    right: 'border-right',
    bottom: 'border-bottom',
    left: 'border-left',
  },
  directions: {
    x: 'border-x',
    y: 'border-y',
  },
};
```

## Usage Rules

### 1. **Border Styles**

- **Solid**: Standard borders for most elements
- **Dashed**: Interactive elements, focus states
- **Dotted**: Decorative elements, separators
- **Double**: Emphasis, special elements
- **None**: No border (default for some elements)

### 2. **Border Widths**

- **0px**: No border
- **1px**: Standard borders, subtle separation
- **2px**: Emphasis, focus states
- **3px**: Strong emphasis, important elements
- **4px+**: Decorative borders, special cases

### 3. **Border Colors**

- **Primary**: Main brand elements, active states
- **Secondary**: Subtle separation, default borders
- **Accent**: Success states, positive feedback
- **Destructive**: Error states, warnings
- **Transparent**: Invisible borders for spacing

## Best Practices

### 1. **Consistent Border Usage**

```tsx
// ✅ Good - Consistent border usage
<div style={{
  border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
  borderRadius: tokens.borderRadius.md,
}}>
  Standard card
</div>

<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
  borderRadius: tokens.borderRadius.lg,
}}>
  Emphasized card
</div>

// ❌ Bad - Inconsistent border usage
<div style={{
  border: '1px solid #e5e5e5',
  borderRadius: '6px',
}}>
  Inconsistent card
</div>

<div style={{
  border: '2px solid #6366f1',
  borderRadius: '12px',
}}>
  Different approach
</div>
```

### 2. **Semantic Border Colors**

```tsx
// ✅ Good - Semantic border colors
<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.success}`,
}}>
  Success state
</div>

<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.destructive}`,
}}>
  Error state
</div>

// ❌ Bad - Non-semantic border colors
<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.colors.primary[500]}`,
}}>
  Success state with primary color
</div>
```

### 3. **Responsive Border Patterns**

```tsx
// ✅ Good - Responsive border patterns
<div style={{
  border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
  '@media (min-width: 768px)': {
    border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
  },
}}>
  Responsive border
</div>

// ❌ Bad - Fixed border without responsiveness
<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
}}>
  Fixed border
</div>
```

### 4. **Accessibility Considerations**

```tsx
// ✅ Good - Accessible border patterns
<div style={{
  border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
  borderRadius: tokens.borderRadius.md,
}} role="button" tabIndex={0}>
  Accessible button
</div>

// ❌ Bad - Inaccessible border patterns
<div style={{
  border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
}}>
  Inaccessible element
</div>
```

## How-To Guides

### Creating a Card Component

```tsx
import { tokens } from '@/design-system/tokens';

interface CardProps {
  variant?: 'default' | 'elevated' | 'outlined' | 'success' | 'error';
  children: React.ReactNode;
}

const Card = ({ variant = 'default', children }: CardProps) => {
  const getBorderStyle = () => {
    switch (variant) {
      case 'default':
        return {
          border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
          borderRadius: tokens.borderRadius.lg,
        };
      case 'elevated':
        return {
          border: 'none',
          borderRadius: tokens.borderRadius.lg,
          boxShadow: tokens.shadows.md,
        };
      case 'outlined':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
          borderRadius: tokens.borderRadius.lg,
        };
      case 'success':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.success}`,
          borderRadius: tokens.borderRadius.lg,
        };
      case 'error':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.destructive}`,
          borderRadius: tokens.borderRadius.lg,
        };
    }
  };

  return (
    <div
      style={{
        ...getBorderStyle(),
        backgroundColor: tokens.colors.white,
        padding: tokens.spacing[6],
      }}
    >
      {children}
    </div>
  );
};
```

### Creating a Button Component

```tsx
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
}

const Button = ({
  variant = 'primary',
  size = 'md',
  children,
}: ButtonProps) => {
  const getBorderStyle = () => {
    switch (variant) {
      case 'primary':
        return {
          border: 'none',
          backgroundColor: tokens.colors.primary[500],
          color: tokens.colors.white,
        };
      case 'secondary':
        return {
          border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
          backgroundColor: tokens.colors.white,
          color: tokens.colors.secondary[700],
        };
      case 'outline':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
          backgroundColor: 'transparent',
          color: tokens.colors.primary[500],
        };
      case 'ghost':
        return {
          border: 'none',
          backgroundColor: 'transparent',
          color: tokens.colors.secondary[700],
        };
    }
  };

  const getSizeStyle = () => {
    switch (size) {
      case 'sm':
        return {
          padding: `${tokens.spacing[2]} ${tokens.spacing[4]}`,
          fontSize: tokens.typography.fontSize.sm,
        };
      case 'md':
        return {
          padding: `${tokens.spacing[3]} ${tokens.spacing[6]}`,
          fontSize: tokens.typography.fontSize.base,
        };
      case 'lg':
        return {
          padding: `${tokens.spacing[4]} ${tokens.spacing[8]}`,
          fontSize: tokens.typography.fontSize.lg,
        };
    }
  };

  return (
    <button
      style={{
        ...getBorderStyle(),
        ...getSizeStyle(),
        borderRadius: tokens.borderRadius.md,
        fontWeight: tokens.typography.fontWeight.medium,
        cursor: 'pointer',
        transition: 'all 0.2s ease',
      }}
    >
      {children}
    </button>
  );
};
```

### Creating a Form Input Component

```tsx
interface InputProps {
  state?: 'default' | 'focused' | 'error' | 'success';
  placeholder?: string;
  value?: string;
  onChange?: (value: string) => void;
}

const Input = ({
  state = 'default',
  placeholder,
  value,
  onChange,
}: InputProps) => {
  const getBorderStyle = () => {
    switch (state) {
      case 'default':
        return {
          border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
        };
      case 'focused':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
        };
      case 'error':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.destructive}`,
        };
      case 'success':
        return {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.success}`,
        };
    }
  };

  return (
    <input
      style={{
        ...getBorderStyle(),
        borderRadius: tokens.borderRadius.md,
        padding: tokens.spacing[3],
        fontSize: tokens.typography.fontSize.base,
        outline: 'none',
        transition: 'all 0.2s ease',
      }}
      placeholder={placeholder}
      value={value}
      onChange={e => onChange?.(e.target.value)}
    />
  );
};
```

## Common Patterns

### Border Variations

```tsx
const BorderVariations = () => {
  const variations = [
    {
      name: 'Default',
      style: {
        border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
        borderRadius: tokens.borderRadius.md,
      },
    },
    {
      name: 'Dashed',
      style: {
        border: `${tokens.border.width[1]} ${tokens.border.style.dashed} ${tokens.border.color.secondary}`,
        borderRadius: tokens.borderRadius.md,
      },
    },
    {
      name: 'Dotted',
      style: {
        border: `${tokens.border.width[1]} ${tokens.border.style.dotted} ${tokens.border.color.secondary}`,
        borderRadius: tokens.borderRadius.md,
      },
    },
    {
      name: 'Double',
      style: {
        border: `${tokens.border.width[3]} ${tokens.border.style.double} ${tokens.border.color.primary}`,
        borderRadius: tokens.borderRadius.md,
      },
    },
  ];

  return (
    <div
      style={{
        display: 'grid',
        gap: tokens.spacing[6],
        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
      }}
    >
      {variations.map((variation, index) => (
        <div
          key={index}
          style={{
            ...variation.style,
            padding: tokens.spacing[6],
            backgroundColor: tokens.colors.white,
          }}
        >
          <h4 style={{ marginBottom: tokens.spacing[3] }}>{variation.name}</h4>
          <p style={{ color: tokens.colors.secondary[700] }}>
            This card demonstrates the {variation.name.toLowerCase()} border
            style.
          </p>
        </div>
      ))}
    </div>
  );
};
```

### Border Radius Scale

```tsx
const BorderRadiusScale = () => {
  const radiuses = [
    { name: 'None', value: tokens.borderRadius.none },
    { name: 'Small', value: tokens.borderRadius.sm },
    { name: 'Medium', value: tokens.borderRadius.md },
    { name: 'Large', value: tokens.borderRadius.lg },
    { name: 'XL', value: tokens.borderRadius.xl },
    { name: '2XL', value: tokens.borderRadius['2xl'] },
    { name: '3XL', value: tokens.borderRadius['3xl'] },
    { name: 'Full', value: tokens.borderRadius.full },
  ];

  return (
    <div
      style={{
        display: 'grid',
        gap: tokens.spacing[6],
        gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
      }}
    >
      {radiuses.map((radius, index) => (
        <div key={index}>
          <div
            style={{
              width: tokens.sizing.width[24],
              height: tokens.sizing.height[24],
              border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
              borderRadius: radius.value,
              marginBottom: tokens.spacing[2],
            }}
          />
          <p
            style={{
              fontSize: tokens.typography.fontSize.sm,
              color: tokens.colors.secondary[600],
            }}
          >
            {radius.name}
          </p>
          <p
            style={{
              fontSize: tokens.typography.fontSize.xs,
              color: tokens.colors.secondary[500],
              fontFamily: 'monospace',
            }}
          >
            {radius.value}
          </p>
        </div>
      ))}
    </div>
  );
};
```

### Responsive Border Example

```tsx
const ResponsiveBorderExample = () => {
  return (
    <div
      style={{
        border: `${tokens.border.width[1]} ${tokens.border.style.solid} ${tokens.border.color.secondary}`,
        borderRadius: tokens.borderRadius.md,
        padding: tokens.spacing[4],
        '@media (min-width: 768px)': {
          border: `${tokens.border.width[2]} ${tokens.border.style.solid} ${tokens.border.color.primary}`,
          borderRadius: tokens.borderRadius.lg,
          padding: tokens.spacing[6],
        },
        '@media (min-width: 1024px)': {
          border: `${tokens.border.width[3]} ${tokens.border.style.dashed} ${tokens.border.color.accent}`,
          borderRadius: tokens.borderRadius.xl,
          padding: tokens.spacing[8],
        },
      }}
    >
      <h3 style={{ marginBottom: tokens.spacing[4] }}>Responsive Border</h3>
      <p style={{ color: tokens.colors.secondary[700] }}>
        This element demonstrates how borders can change based on screen size.
        On mobile, it has a thin solid border. On tablet, it has a medium
        primary border. On desktop, it has a thick dashed accent border.
      </p>
    </div>
  );
};
```

## Accessibility Guidelines

### 1. **Contrast Requirements**

- Ensure border colors meet WCAG contrast requirements
- Test borders in high contrast mode
- Provide alternative visual cues when borders are insufficient

### 2. **Focus Indicators**

- Use appropriate border styles for focus states
- Ensure focus borders are clearly visible
- Test focus indicators with different color schemes

### 3. **Screen Reader Support**

- Don't rely solely on borders to convey information
- Use semantic HTML elements with proper ARIA attributes
- Provide text alternatives for visual border indicators

### 4. **Responsive Accessibility**

- Ensure borders remain accessible across all screen sizes
- Test border visibility on different devices
- Maintain accessibility when borders change responsively

## Testing Checklist

- [ ] Border styles work correctly across all screen sizes
- [ ] Border colors meet contrast requirements
- [ ] Focus indicators are clearly visible
- [ ] Borders don't interfere with accessibility
- [ ] Responsive border changes function properly
- [ ] Border radius values render correctly
- [ ] Border utilities work as expected

## Resources

- [CSS Border Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/border)
- [Border Radius CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius)
- [Border Accessibility](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html)
