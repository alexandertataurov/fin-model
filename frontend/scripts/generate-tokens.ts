/*
  Auto-generates src/design-system/tokens.ts from src/design-system/tokens.json
  Usage: pnpm gen:tokens
*/

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

type DeepRecord = Record<string, any>;

const __filename = fileURLToPath(import.meta.url);
const ROOT = path.resolve(__filename, '../..');

function safeResolve(...segments: string[]): string {
  const resolved = path.resolve(...segments);
  return resolved;
}

const JSON_PATH = safeResolve(ROOT, 'src', 'design-system', 'tokens', 'tokens.json');
const OUTPUT_PATH = safeResolve(ROOT, 'src', 'design-system', 'tokens', 'tokens.ts');

function readJson(filePath: string): DeepRecord {
  const resolved = safeResolve(filePath);
  const raw = fs.readFileSync(resolved, 'utf8');
  return JSON.parse(raw);
}

function header(): string {
  return `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-tokens.ts from src/design-system/tokens/tokens.json

`;
}

function extractValue(token: any): any {
  if (token && typeof token === 'object' && 'value' in token) {
    return token.value;
  }
  return token;
}

function normalizeColors(jsonColors: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonColors).forEach((k) => {
    const v = jsonColors[k];
    if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
      if ('value' in v) {
        // Single color value
        out[k] = extractValue(v);
      } else {
        // Color scale
        out[k] = {};
        Object.keys(v).forEach((scale) => {
          out[k][scale] = extractValue(v[scale]);
        });
      }
    } else {
      out[k] = extractValue(v);
    }
  });
  return out;
}

function normalizeTypography(jsonTypography: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonTypography).forEach((k) => {
    const v = jsonTypography[k];
    if (typeof v === 'object' && v !== null) {
      out[k] = {};
      Object.keys(v).forEach((prop) => {
        out[k][prop] = extractValue(v[prop]);
      });
    } else {
      out[k] = extractValue(v);
    }
  });
  return out;
}

function normalizeSpacing(jsonSpacing: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonSpacing).forEach((k) => {
    const v = jsonSpacing[k];
    out[k] = extractValue(v);
  });
  return out;
}

function normalizeRadius(jsonRadius: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonRadius).forEach((k) => {
    const v = jsonRadius[k];
    out[k] = extractValue(v);
  });
  return out;
}

function normalizeBorderWidth(jsonBorderWidth: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonBorderWidth).forEach((k) => {
    const v = jsonBorderWidth[k];
    out[k] = extractValue(v);
  });
  return out;
}

function normalizeShadows(jsonShadows: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonShadows).forEach((k) => {
    const v = jsonShadows[k];
    out[k] = extractValue(v);
  });
  return out;
}

function normalizeMotion(jsonMotion: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonMotion).forEach((k) => {
    const v = jsonMotion[k];
    if (typeof v === 'object' && v !== null) {
      out[k] = {};
      Object.keys(v).forEach((prop) => {
        out[k][prop] = extractValue(v[prop]);
      });
    } else {
      out[k] = extractValue(v);
    }
  });
  return out;
}

function normalizeZIndex(jsonZIndex: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonZIndex).forEach((k) => {
    const v = jsonZIndex[k];
    out[k] = extractValue(v);
  });
  return out;
}

function normalizeBreakpoints(jsonBreakpoints: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonBreakpoints).forEach((k) => {
    const v = jsonBreakpoints[k];
    out[k] = extractValue(v);
  });
  return out;
}

function buildTokensTs(tokensJson: DeepRecord): string {
  const colors = normalizeColors(tokensJson.colors || {});
  const typography = normalizeTypography(tokensJson.typography || {});
  const spacing = normalizeSpacing(tokensJson.spacing || {});
  const borderRadius = normalizeRadius(tokensJson.borderRadius || {});
  const borderWidth = normalizeBorderWidth(tokensJson.borderWidth || {});
  const shadows = normalizeShadows(tokensJson.shadows || {});
  const motion = normalizeMotion(tokensJson.motion || {});
  const zIndex = normalizeZIndex(tokensJson.zIndex || {});
  const breakpoints = normalizeBreakpoints(tokensJson.breakpoints || {});

  return `${header()}export const tokens = {
  colors: ${JSON.stringify(colors, null, 2)},
  typography: ${JSON.stringify(typography, null, 2)},
  spacing: ${JSON.stringify(spacing, null, 2)},
  borderRadius: ${JSON.stringify(borderRadius, null, 2)},
  borderWidth: ${JSON.stringify(borderWidth, null, 2)},
  shadows: ${JSON.stringify(shadows, null, 2)},
  motion: ${JSON.stringify(motion, null, 2)},
  zIndex: ${JSON.stringify(zIndex, null, 2)},
  breakpoints: ${JSON.stringify(breakpoints, null, 2)},
} as const;

export const getToken = (path: string) => {
  return path.split('.').reduce((obj: any, key: string) => obj?.[key], tokens);
};

export const getCSSVariable = (name: string) => {
  return \`var(\${name})\`;
};
`;
}

function main() {
  try {
    console.log('Reading tokens from:', JSON_PATH);
    const tokensJson = readJson(JSON_PATH);
    
    console.log('Generating TypeScript tokens...');
    const tokensTs = buildTokensTs(tokensJson);
    
    console.log('Writing to:', OUTPUT_PATH);
    fs.writeFileSync(OUTPUT_PATH, tokensTs, 'utf8');
    
    console.log('✅ Tokens generated successfully!');
  } catch (error) {
    console.error('❌ Error generating tokens:', error);
    process.exit(1);
  }
}

main();
