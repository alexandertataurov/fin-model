/*
  Auto-generates src/design-system/tokens.ts from src/design-system/tokens.json
  Usage: pnpm gen:tokens
*/

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

type DeepRecord = Record<string, any>;

const __filename = fileURLToPath(import.meta.url);
const __dirnameESM = path.dirname(__filename);
const ROOT = path.resolve(__dirnameESM, '..');

function safeResolve(...segments: string[]): string {
  const resolved = path.resolve(...segments);
  if (!resolved.startsWith(ROOT)) {
    throw new Error('Invalid path');
  }
  return resolved;
}

const JSON_PATH = safeResolve(ROOT, 'src', 'design-system', 'tokens.json');
const OUTPUT_PATH = safeResolve(ROOT, 'src', 'design-system', 'tokens.ts');

function readJson(filePath: string): DeepRecord {
  const resolved = safeResolve(filePath);
  const raw = fs.readFileSync(resolved, 'utf8');
  return JSON.parse(raw);
}

function header(): string {
  return `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-tokens.ts from src/design-system/tokens.json

`;
}

function serialize(obj: unknown, indent = 2): string {
  return JSON.stringify(obj, null, indent)
    .replace(/"/g, "'")
    .replace(/'([0-9]+)'(?=\s*:)/g, '$1');
}

// Helpers to normalize values
const toRem = (value: number | string): string => {
  if (typeof value === 'number') {
    return `${(value / 16).toFixed(4).replace(/\.0+$/, '').replace(/0+$/, '')}rem`;
  }
  if (/^\d+(px)?$/.test(value)) {
    const px = parseFloat(value);
    return `${(px / 16).toFixed(4).replace(/\.0+$/, '').replace(/0+$/, '')}rem`;
  }
  return value;
};

function buildTypography(jsonTypography: DeepRecord): DeepRecord {
  // Accept either already-normalized { fontSize: { sm: ['0.875rem', { lineHeight: '1.25rem'}], ... } }
  // or split maps { fontSizes: { sm: '14px' }, lineHeights: { sm: '20px' } }
  const fontSize = jsonTypography.fontSize
    ? jsonTypography.fontSize
    : ((): DeepRecord => {
      const sizes: DeepRecord = {};
      const fontSizes: DeepRecord = jsonTypography.fontSizes || {};
      const lineHeights: DeepRecord = jsonTypography.lineHeights || {};
      Object.keys(fontSizes).forEach((key) => {
        const size = toRem(fontSizes[key]);
        const lhRaw = lineHeights[key];
        // If line-height is provided in px/number, convert to rem; if percentage/unitless, keep
        const lineHeight = lhRaw ? toRem(lhRaw) : '1.5rem';
        sizes[key] = [size, { lineHeight }];
      });
      return sizes;
    })();

  const result: DeepRecord = { fontSize };
  if (jsonTypography.fontFamily) result.fontFamily = jsonTypography.fontFamily;
  if (jsonTypography.fontWeight) result.fontWeight = jsonTypography.fontWeight;
  if (jsonTypography.letterSpacing) result.letterSpacing = jsonTypography.letterSpacing;
  if (jsonTypography.lineHeight) result.lineHeight = jsonTypography.lineHeight;
  if (jsonTypography.textStyles) result.textStyles = jsonTypography.textStyles;
  return result;
}

function normalizeSpacing(jsonSpacing: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonSpacing).forEach((k) => {
    // Don't convert spacing values that are already in rem or other units
    const v = jsonSpacing[k];
    if (typeof v === 'string' && (v.includes('rem') || v.includes('px') || v === '0')) {
      out[k] = v;
    } else {
      out[k] = toRem(v);
    }
  });
  return out;
}

function normalizeRadius(jsonRadius: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonRadius).forEach((k) => {
    // Don't convert radius values that are already in rem or other units
    const v = jsonRadius[k];
    if (typeof v === 'string' && (v.includes('rem') || v.includes('px') || v === '0' || v === '9999px')) {
      out[k] = v;
    } else {
      out[k] = toRem(v);
    }
  });
  return out;
}

function normalizeBorderWidth(jsonBorderWidth: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonBorderWidth).forEach((k) => {
    const v = jsonBorderWidth[k];
    if (v === '0' || v === 0) {
      out[k] = '0';
    } else if (typeof v === 'string' && v.includes('px')) {
      out[k] = v;
    } else {
      out[k] = toRem(v);
    }
  });
  return out;
}

function normalizeTransitions(jsonTransitions: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonTransitions).forEach((k) => {
    const v = jsonTransitions[k];
    out[k] = typeof v === 'string' && /\s/.test(v) ? v : `${v} ease-in-out`;
  });
  return out;
}

function normalizeMotion(jsonMotion: DeepRecord): DeepRecord {
  const out: DeepRecord = {};
  Object.keys(jsonMotion).forEach((k) => {
    const v = jsonMotion[k];
    if (typeof v === 'object') {
      out[k] = v;
    } else {
      out[k] = v;
    }
  });
  return out;
}

function normalizeCssVariables(cssVars: DeepRecord): DeepRecord {
  // Support { light: {...}, dark: {...} } or CSS selectors { ':root': {...}, '.dark': {...} }
  if (cssVars.light || cssVars.dark) return cssVars;
  const light = cssVars[':root'] || {};
  const dark = cssVars['.dark'] || {};
  return { light, dark };
}

function buildTokensTs(tokensJson: DeepRecord): string {
  const colors = tokensJson.colors || {};
  const typography = buildTypography(tokensJson.typography || {});
  const spacing = normalizeSpacing(tokensJson.spacing || {});
  const borderRadius = normalizeRadius(tokensJson.borderRadius || {});
  const borderWidth = normalizeBorderWidth(tokensJson.borderWidth || {});
  const shadows = tokensJson.shadows || {};
  const transitions = normalizeTransitions(tokensJson.transitions || {});
  const motion = normalizeMotion(tokensJson.motion || {});
  const zIndex = tokensJson.zIndex || {};
  const cssVariables = normalizeCssVariables(tokensJson.cssVariables || {});

  const tokensBlock = `export const tokens = ${serialize({
    colors,
    typography,
    spacing,
    borderRadius,
    borderWidth,
    shadows,
    transitions,
    motion,
    zIndex,
  })} as const;`;

  const cssVarsBlock = `\n\nexport const cssVariables = ${serialize(
    cssVariables
  )} as const;`;

  const utilsBlock = `\n\nexport const getToken = (path: string) => {
  return path.split('.').reduce((obj: any, key: string) => obj?.[key], tokens);
};

export const getCSSVariable = (name: string) => {
  return \`var(\${name})\`;
};
`;

  return header() + tokensBlock + cssVarsBlock + utilsBlock;
}

function main() {
  if (!fs.existsSync(JSON_PATH)) {
    throw new Error(`tokens.json not found at ${JSON_PATH}`);
  }
  const json = readJson(JSON_PATH);
  const out = buildTokensTs(json);
  fs.writeFileSync(OUTPUT_PATH, out, 'utf8');
  // eslint-disable-next-line no-console
  console.log(
    `Generated ${path.relative(ROOT, OUTPUT_PATH)} from ${path.relative(
      ROOT,
      JSON_PATH
    )}`
  );
}

main();
